"""7GUIs Task 5: CRUD.

We use a simple python dict as database. It is easy enough to replace with a
real ORM.

For a real application, it might be preferable to have individual files for each
class, but let's keep it together here.

The GUI is split up into a "parent frame" and 3 subframes for the individual areas.
"""

from tkinter.messagebox import showerror
import itertools as it
import dataclasses as dc
from multiprocessing import Event
from ascii_designer import set_toolkit, AutoFrame, Invalid, EventSource


#== Model ========================================

@dc.dataclass(frozen=True)
class Person:
    id: int
    """Unique identification. 0 for non-database record."""
    name: str
    surname: str

    def __str__(self):
        return f"{self.name}, {self.surname}"



DEMO_TABLE = {
    1: Person(1, "Emil", "Hans"),
    2: Person(2, "Mustermann", "Max"),
    3: Person(3, "Tisch", "Roman")
}

#== Data access layer ========================================

class DBInterface:
    def __init__(self, person_table=None):
        self.person_table = person_table or {}
        if not person_table:
            start = 1
        else:
            start = max(person_table.keys())+1
        self._id_counter = it.count(start)

    # Pro-forma context manager implementation.
    # In this functions, we would open/close IO connections,
    # but none are needed for our fake DB.
    def __enter__(self):
        return self

    def __exit__(self, etype, exc, tb):
        pass

    def upsert(self, record:Person) -> Person:
        """Stores the given record in the database.
        
        * If the given record is new (id=0), stores it with autogenerated id.
        * If the given record is in the DB, update it.
        * If the given record's ID is not in the DB, raises ValueError.

        Returns: Stored record, possibly with new ID.
        """
        table = self.person_table
        if record.id and record.id not in table:
            raise ValueError(f"Record {record.id} is not in database.")
        if not record.id:
            record = dc.replace(record, id=next(self._id_counter))
        table[record.id] = record
        return record

    def delete(self, record: Person):
        """Delete the given record."""
        table = self.person_table
        if record.id not in table:
            raise ValueError(f"Record {record.id} is not in database.")
        del table[record.id]

    def filter_persons(self, surname_prefix=""):
        """Return list of all persons whose surname starts with ``surname_prefix``.
        
        Surname matching is done case insensitive.

        List is ordered by name, then by surname, then by id.
        """
        # Filtering by surname instead of name seems a bit strange, but it is
        # specified so in the task.
        table = self.person_table
        surname_prefix = surname_prefix.lower()
        matches = [p for p in table.values() if p.surname.lower().startswith(surname_prefix)]
        return sorted(matches, key=lambda p: (p.name, p.surname, p.id))

#== GUI ========================================

def nonempty(s):
    if not s:
        raise ValueError("Expected nonempty string")
    return str(s)


class CRUD(AutoFrame):
    f_title = "CRUD"

    # The layout is easier to do by using sub-frames for each area.
    # Usually this coincides with "separation of concerns" in the code, that you
    # should do anyways.
    f_body = """
        |               |  -   |        |
         Filter prefix:  [_   ]
         <person_list   ~     > <editor>
         <actions       ~      ~       >
    """

    def __init__(self, db_interface):
        super().__init__()
        self.db = db_interface

    def f_on_build(self):
        self.person_list = PersonList()
        self.editor = PersonEditor()
        self.actions = CrudActions(self.db, self.editor)

        # Event wireup
        self.person_list.person_selected += self._on_person_select
        self.actions.on_created += self.person_list.add_person
        self.actions.on_updated += self.person_list.update_person
        self.actions.on_deleted += self.person_list.delete_person

        self["filter_prefix"].bind("<KeyRelease>", lambda _: self._filter_changed())
        # init list
        self._filter_changed()

    def _filter_changed(self):
        persons = self.db.filter_persons(surname_prefix=self.filter_prefix)
        self.person_list.set_list(persons)

    def _on_person_select(self, person):
        person = person or Person(0, "", "")
        self.editor.person = person
        self.actions.update_ctls(self.editor.person)

class PersonList(AutoFrame):
    f_body = """
        |       -
        I[= Persons         ]
    """
    def __init__(self):
        super().__init__()
        self.person_selected: EventSource = EventSource()
        """person_selected(person): when a person is selected in the table.
        
        On deselection, person is ``None``.
        """

    def f_on_build(self):
        self["persons"]["selectmode"] = "browse"

    def set_list(self, persons):
        self.persons = persons

    def on_persons(self, person):
        self.person_selected(person)

    def add_person(self, person, autoselect=True):
        """Append person to the list"""
        self.persons.append(person)
        if autoselect:
            tkid = self.persons.toolkit_ids[-1]
            self["persons"].focus(tkid)
            self["persons"].selection_set(tkid)
            self.person_selected(person)

    def _find_idxs(self, person_id):
        return [n for n, p in enumerate(self.persons) if p.id == person_id]

    def update_person(self, person):
        for idx in self._find_idxs(person.id):
            self.persons[idx] = person

    def delete_person(self, person_id):
        for idx in self._find_idxs(person_id)[::-1]:
            self.persons.pop(idx)
        focus = self["persons"].focus()
        if focus == "":
            self.person_selected(None)
        else:
            idx = self.persons.find_by_toolkit_id2(focus)
            self.person_selected(self.persons[idx])


class PersonEditor(AutoFrame):
    f_body = """
        |         |      |
         Name:     [_   ]
         Surname:  [_   ]
    """
    def __init__(self):
        super().__init__()
        self._person = Person(0, "", "")
        self.person_changed:EventSource = EventSource()
        """person_changed(person): whenever edits were done."""

    @property
    def person(self):
        """Currently edited person.
        
        Returns Invalid if field content is invalid.
        """
        return self._edited_person()

    @person.setter
    def person(self, val):
        self._person = val
        self._update_ctls()

    def f_on_build(self):
        self["name"].variable.convert = nonempty
        self["surname"].variable.convert = nonempty

    def _update_ctls(self):
        self.name = self._person.name
        self.surname =self._person.surname
    
    def _edited_person(self):
        name =self.name
        surname= self.surname
        if Invalid in (name, surname):
            return Invalid
        return dc.replace(self._person, name=name, surname=surname)

    def on_name(self, _):
        self.person_changed(self.person)

    def on_surname(self, _):
        self.person_changed(self.person)


class CrudActions(AutoFrame):
    f_body = """
        |        |        |        |
         [Create] [Update] [Delete]
    """
    def __init__(self, db_interface, editor):
        super().__init__()
        self._db = db_interface
        self._editor = editor
        self._editor.person_changed += self.update_ctls

        self.on_created: EventSource = EventSource()
        """on_created(stored_person)"""
        self.on_updated: EventSource = EventSource()
        """on_updated(stored_person)"""
        self.on_deleted: EventSource = EventSource()
        """on_deleted(person_id)"""

    def f_on_build(self):
        self.update_ctls(self._editor.person)

    def update_ctls(self, edited_person):
        def enbl(name, enbl):
            self[name].state(["!disabled"] if enbl else ["disabled"])
        person = edited_person
        enbl("create", person is not Invalid)
        enbl("update", person is not Invalid and person.id>0)
        enbl("delete", person is not Invalid and person.id>0)

    def create(self):
        person = dc.replace(self._editor.person, id=0)
        person = self._db.upsert(person)
        self.on_created(person)
    
    def update(self):
        person = self._editor.person
        self._db.upsert(person)
        self.on_updated(person)
    
    def delete(self):
        person = self._editor.person
        self._db.delete(person)
        self.on_deleted(person.id)


if __name__ == "__main__":
    set_toolkit("ttk")
    with DBInterface(DEMO_TABLE) as db_interface:
        CRUD(db_interface).f_show()