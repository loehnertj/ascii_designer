"""7GUIs Task 5: CRUD.

We use a simple python dict as database. It is easy enough to replace with a
real ORM.

For a real application, it might be preferable to have individual files for each
class, but let's keep it together here.

"""

import itertools as it
import dataclasses as dc
from ascii_designer import set_toolkit, AutoFrame, Invalid


# == Model ========================================


@dc.dataclass(frozen=True)
class Person:
    id: int
    """Unique identification. 0 for non-database record."""
    name: str
    surname: str

    def __str__(self):
        return f"{self.name}, {self.surname}"


DEMO_TABLE = {
    1: Person(1, "Emil", "Hans"),
    2: Person(2, "Mustermann", "Max"),
    3: Person(3, "Tisch", "Roman"),
}

# == Data access layer ========================================


class DBInterface:
    def __init__(self, person_table=None):
        self.person_table = person_table or {}
        if not person_table:
            start = 1
        else:
            start = max(person_table.keys()) + 1
        self._id_counter = it.count(start)

    # Pro-forma context manager implementation.
    # In this functions, we would open/close IO connections,
    # but none are needed for our fake DB.
    def __enter__(self):
        return self

    def __exit__(self, etype, exc, tb):
        pass

    def upsert(self, record: Person) -> Person:
        """Stores the given record in the database.

        * If the given record is new (id=0), stores it with autogenerated id.
        * If the given record is in the DB, update it.
        * If the given record's ID is not in the DB, raises ValueError.

        Returns: Stored record, possibly with new ID.
        """
        table = self.person_table
        if record.id and record.id not in table:
            raise ValueError(f"Record {record.id} is not in database.")
        if not record.id:
            record = dc.replace(record, id=next(self._id_counter))
        table[record.id] = record
        return record

    def delete(self, record: Person):
        """Delete the given record."""
        table = self.person_table
        if record.id not in table:
            raise ValueError(f"Record {record.id} is not in database.")
        del table[record.id]

    def filter_persons(self, surname_prefix=""):
        """Return list of all persons whose surname starts with ``surname_prefix``.

        Surname matching is done case insensitive.

        List is ordered by name, then by surname, then by id.
        """
        # Filtering by surname instead of name seems a bit strange, but it is
        # specified so in the task.
        table = self.person_table
        surname_prefix = surname_prefix.lower()
        matches = [
            p for p in table.values() if p.surname.lower().startswith(surname_prefix)
        ]
        return sorted(matches, key=lambda p: (p.name, p.surname, p.id))


# == GUI ========================================


def nonempty(s):
    if not s:
        raise ValueError("Expected nonempty string")
    return str(s)


class CRUD(AutoFrame):
    f_title = "CRUD"

    # The layout is easier to do by using subframes for editor and actions areas.
    f_body = """
        |               |  -   |        |
         Filter prefix:  [_   ]
        I[= Persons     ~     ] <editor>
         <actions       ~      ~       >
    """
    # Subframes, these are "nonstandard" attributes
    f_body_editor = """
        |         |      |
         Name:     [_   ]
         Surname:  [_   ]
    """
    f_body_actions = """
        |        |        |        |
         [Create] [Update] [Delete]
    """

    def __init__(self, db_interface: DBInterface):
        super().__init__()
        self.db = db_interface
        # active person
        self._person = Person(0, "", "")

    def f_on_build(self):
        self.f_add_widgets(self.editor, body=self.f_body_editor, autoframe=self)
        self.f_add_widgets(self.actions, body=self.f_body_actions, autoframe=self)

        # Setup widgets
        self["persons"]["selectmode"] = "browse"
        self["name"].variable.convert = nonempty
        self["surname"].variable.convert = nonempty

        # Find-as-you-type
        self["filter_prefix"].bind("<KeyRelease>", lambda _: self._filter_changed())
        self._filter_changed()  # to populate listview
        self.update_action_ctls()

    # -- Person list ----------------------------------------

    def _filter_changed(self):
        self.persons = self.db.filter_persons(surname_prefix=self.filter_prefix)

    def on_persons(self, person):
        person = person or Person(0, "", "")
        self._person = person
        self.name = person.name
        self.surname = person.surname
        self.update_action_ctls()

    def _find_idxs(self, person_id):
        return [n for n, p in enumerate(self.persons) if p.id == person_id]

    # -- Editor ----------------------------------------

    def on_name(self, _):
        self.update_action_ctls()

    def on_surname(self, _):
        self.update_action_ctls()

    def _edited_person(self):
        """Create Person record with changed fields according to current input.

        Returns ``Invalid`` if validation failed.
        """
        name = self.name
        surname = self.surname
        if Invalid in (name, surname):
            return Invalid
        return dc.replace(self._person, name=name, surname=surname)

    # -- Actions ----------------------------------------

    def update_action_ctls(self):
        def enbl(name, enbl):
            self[name].state(["!disabled"] if enbl else ["disabled"])

        person = self._edited_person()
        enbl("create", person is not Invalid)
        enbl("update", person is not Invalid and person.id > 0)
        enbl("delete", person is not Invalid and person.id > 0)

    def create(self):
        person = dc.replace(self._edited_person(), id=0)
        person = self.db.upsert(person)

        # Add to list view and focus
        # XXX: We always add the person, regardless whether it meets the filter
        # or not, to indicate that creation was successful.
        self.persons.append(person)
        tkid = self.persons.toolkit_ids[-1]
        self["persons"].focus(tkid)
        self["persons"].selection_set(tkid)
        self.on_persons(person)

    def update(self):
        person = self._edited_person()
        person = self.db.upsert(person)

        # Update in list.
        for idx in self._find_idxs(person.id):
            self.persons[idx] = person

    def delete(self):
        person = self._edited_person()
        self.db.delete(person)

        # Remove from list and clear focus
        # XXX: In theory a record cannot appear multiple times, but we're
        # prepared in case it does --> go in reverse.
        for idx in reversed(self._find_idxs(person.id)):
            self.persons.pop(idx)
        self.on_persons(None)


if __name__ == "__main__":
    set_toolkit("ttk")
    with DBInterface(DEMO_TABLE) as db_interface:
        CRUD(db_interface).f_show()
